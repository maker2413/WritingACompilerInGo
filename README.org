#+TITLE: Writing An Interpreter In Go.git

This is my repo containing the code that follows along with the book:
[[https://interpreterbook.com/][How to Build an Interpreter in Go]].

This repository builds out an interpreter for the made up programming language
"Monkey". Monkey supports the following:
- integers
- booleans
- strings
- arrays
- hashes
- prefix-, infix-, and index operators
- conditionals
- global and local bindings
- first-class functions
- return statements
- closures

Here is a small snippet that tries to cram as much of Monkey's features into as
few lines as possible:
#+begin_example
  let name = "Monkey";
  let age = 1;
  let inspirations = ["Scheme", "Lisp", "JavaScript", "Clojure"];
  let book = {
    "title": "Writing A Compiler In Go",
    "author": "Thorsten Ball",
    "prequel": "Writing An Interpreter In Go"
  };

  let printBookName = fn(book) {
    let title = book["title"];
    let author = book["author"];
    puts(author + " - " + title);
  };

  printBookName(book);
  // => prints: "Thorsten Ball - Writing A Compiler In Go"

  let fibonacci = fn(x) {
    if (x == 0) {
      0
    } else {
      if (x == 1) {
        return 1;
      } else {
        fibonacci(x - 1) + fibonacci(x - 2);
      }
    }
  };

  let map = fn(arr, f) {
    let iter = fn(arr, accumulated) {
      if (len(arr) == 0) {
        accumulated
      } else {
        iter(rest(arr), push(accumulated, f(first(arr))));
      }
    };

    iter(arr, []);
  };

  let numbers = [1, 1 + 1, 4 - 1, 2 * 2, 2 + 3, 12 / 2];
  map(numbers, fibonacci);
  // => returns: [1, 1, 2, 3, 5, 8]
#+end_example

If you want to learn some of the concept used to make Monkey's interpreter I
highly recommend the book as it was a great, insightful read.

* Terms
  - AST :: Abstract Syntax Tree
  - JIT :: Just In Time
  - IR :: Intermediate Representation
